#!/usr/bin/env node

const async = require('async');
const path = require('path');
const yargs = require('yargs');
const comments = require('parse-comments');
const decomment = require('decomment');
const showdown = require('showdown');
const fs = require('fs');
const glob = require('glob');
const _ = require('lodash');

const argv = yargs
  .option('allRules', {
    alias: 'a',
    default: false
  })
  .option('outputPath', {
    alias: 'o',
    default: __dirname + '/rules.json'
  })
  .argv;

const files = glob.sync(__dirname + '/src/rules/*.js');

const converter = new showdown.Converter();
showdown.setFlavor('github');

async.reduce(files, [], (rules, file, callback) => {

  fs.readFile(file, 'utf8', (err, data) => {
    if (err) return callback(err);

    const comment = comments(data, { trim: true })[0];

    if (argv.allRules || comment.gallery === 'true') {
      const rule = {
        id: path.basename(file).replace('.js', ''),
        title: comment.title,
        overview: comment.overview,
        categories: comment.category ? comment.category.split(',') : ['default'],
        description: converter.makeHtml(comment.example),
        code: decomment(data, { trim: true })
      }
      rules.push(rule);
    }

    return callback(null, rules);
  });
}, (err, rules) => {
  if (err) {
    console.log(err.stack);
    process.exit(1);
  }

  const expandedRules = _.chain(rules)
    .flatMap(rule => _.map(rule.categories, category => _.assign(_.clone(rule), { category })))
    .groupBy(r => r.category)
    .map((rules, category) => ({
      name: category,
      templates: _.map(rules, rule => _.omit(rule, 'category'))
    }))
    .value();

  console.log(`rules written to ${argv.outputPath}`);
  fs.writeFileSync(argv.outputPath, JSON.stringify(expandedRules, null, 2));
  process.exit(0);
});
